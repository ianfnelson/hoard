# 002. Saga Correlation Keys

Date: 2026-02-09

## Status

Accepted (documenting existing implementation)

## Context

Hoard uses Rebus sagas for orchestrating multi-step processes (CloseOfDaySaga, CalculateValuationsSaga, etc.). Sagas need to correlate incoming events to the correct saga instance.

**Two correlation strategies:**

1. **Single-field correlation:** Use one field (e.g., `Date` or `PortfolioId`)
   ```csharp
   [CorrelateOn(nameof(Date))]
   ```

2. **Composite correlation:** Use multiple fields (e.g., `PortfolioId + Date`)
   ```csharp
   [CorrelateOn(nameof(PortfolioId), nameof(Date))]
   ```

**Problem:** Which strategy to use? Each has trade-offs for concurrency, uniqueness, and testability.

**Requirements:**
1. Prevent duplicate saga instances for same operation
2. Allow parallel processing where safe
3. Simplify debugging (clear correlation in logs)
4. Support saga replays for failed operations

## Decision

Use **different correlation strategies based on saga scope:**

### Strategy 1: Date-Only Correlation (CloseOfDaySaga)

**Use for:** System-wide daily operations

**Correlation key:** `Date` (single field)

```csharp
[CorrelateOn(nameof(Date))]
public class CloseOfDaySagaData
{
    public DateOnly Date { get; set; }
    // ...
}
```

**Rationale:**
- Only one CloseOfDay should run per date
- Prevents concurrent runs for same date (e.g., manual retry during scheduled run)
- Simplifies debugging: "What happened on 2024-01-15?" → Check saga for that date

**Trade-off:** Cannot process multiple dates in parallel (acceptable for nightly batch)

### Strategy 2: Portfolio + Date Correlation (ValuationsSaga, PerformanceSaga)

**Use for:** Portfolio-specific calculations

**Correlation key:** `PortfolioId + Date` (composite)

```csharp
[CorrelateOn(nameof(PortfolioId), nameof(Date))]
public class CalculateValuationsSagaData
{
    public Guid PortfolioId { get; set; }
    public DateOnly Date { get; set; }
    // ...
}
```

**Rationale:**
- Each portfolio's calculations are independent
- Allows parallel processing across portfolios
- Prevents duplicate calculations for same portfolio + date

**Trade-off:** More complex correlation (two fields), but enables parallelism

### Strategy 3: RunId Correlation (Nested Sagas)

**Use for:** Ephemeral sagas orchestrated by parent saga

**Correlation key:** `RunId` (unique GUID generated by parent)

```csharp
[CorrelateOn(nameof(RunId))]
public class RefreshPricesSagaData
{
    public Guid RunId { get; set; }
    // ...
}
```

**Rationale:**
- Parent saga generates unique RunId for each invocation
- Clear parent-child relationship
- Prevents cross-contamination between different CloseOfDay runs
- Simplifies debugging: filter logs by RunId

**Trade-off:** Requires parent to generate and track RunId

## Consequences

### Positive

1. **Prevents duplicate processing:** Single correlation key per operation type ensures idempotency
2. **Enables parallelism where safe:** Portfolio-level sagas can run concurrently
3. **Clear debugging:** Correlation keys are visible in logs and saga storage
4. **Supports replay:** Failed sagas can be restarted with same correlation key

### Negative

1. **Inconsistent patterns:** Different sagas use different strategies (learning curve)
2. **Composite key complexity:** Two-field correlation is harder to understand
3. **RunId tracking burden:** Parent sagas must manage child RunIds
4. **No cross-date parallelism:** CloseOfDaySaga processes dates sequentially

### Neutral

1. **Database indexing:** Saga storage must index all correlation keys (minor performance impact)
2. **Manual saga cleanup:** Old saga instances must be manually pruned (no auto-expiration)

## Implementation Notes

### File Locations

**Date-only correlation:**
- `/Hoard.Bus/Chrono/CloseOfDaySaga.cs` - `[CorrelateOn(nameof(Date))]`

**Portfolio + Date correlation:**
- `/Hoard.Bus/Valuations/CalculateValuationsSaga.cs` - `[CorrelateOn(nameof(PortfolioId), nameof(Date))]`
- `/Hoard.Bus/Performance/CalculatePerformanceSaga.cs` - `[CorrelateOn(nameof(PortfolioId), nameof(Date))]`

**RunId correlation:**
- `/Hoard.Bus/Chrono/RefreshPricesSaga.cs` - `[CorrelateOn(nameof(RunId))]`

**Rebus saga storage:**
- `/Hoard.Core/Infrastructure/ServiceCollectionExtensions.cs` - Configures SQL Server saga storage

### Example: Parent-Child RunId Flow

```csharp
// Parent saga (CloseOfDaySaga)
public async Task Handle(StartCloseOfDaySagaCommand message)
{
    Data.PricesRunId = Guid.NewGuid(); // ← Generate unique RunId
    await _bus.Send(new StartRefreshPricesSagaCommand(Data.PricesRunId));
}

// Child saga (RefreshPricesSaga)
[CorrelateOn(nameof(RunId))]
public class RefreshPricesSagaData
{
    public Guid RunId { get; set; } // ← Correlate by RunId
}

// Child saga completion
public async Task Handle(PricesFetchedEvent message)
{
    await _bus.Publish(new PricesRefreshedEvent(Data.RunId)); // ← Parent uses RunId to correlate
}

// Parent saga receives completion
public async Task Handle(PricesRefreshedEvent message)
{
    if (message.RunId != Data.PricesRunId) return; // ← Guard clause
    Data.PricesRefreshed = true; // ← Update state
}
```

### Querying Saga State

```sql
-- Find saga by Date
SELECT * FROM [RebusMessages].[Sagas]
WHERE [SagaType] = 'CloseOfDaySaga'
  AND JSON_VALUE([Data], '$.Date') = '2024-01-15';

-- Find saga by PortfolioId + Date
SELECT * FROM [RebusMessages].[Sagas]
WHERE [SagaType] = 'CalculateValuationsSaga'
  AND JSON_VALUE([Data], '$.PortfolioId') = 'abc-123'
  AND JSON_VALUE([Data], '$.Date') = '2024-01-15';

-- Find saga by RunId
SELECT * FROM [RebusMessages].[Sagas]
WHERE [SagaType] = 'RefreshPricesSaga'
  AND JSON_VALUE([Data], '$.RunId') = 'xyz-789';
```

## Alternatives Considered

### Alternative 1: Always Use Single-Field Correlation

**Description:** Use only `Date` for all sagas (no composite keys, no RunId).

**Pros:**
- Simplest implementation
- Consistent pattern across all sagas

**Cons:**
- Prevents parallel processing across portfolios
- Forces sequential execution (poor performance)
- Cannot distinguish between different runs of same date

**Reason for rejection:** Performance unacceptable (sequential portfolio processing takes 10× longer)

### Alternative 2: Use Globally Unique RunId for Everything

**Description:** Generate RunId for every operation; correlate all sagas by RunId only.

**Pros:**
- Consistent pattern (always RunId)
- Maximum parallelism (no natural key conflicts)
- Easy to trace through logs

**Cons:**
- Loses semantic meaning (RunId doesn't tell you which date/portfolio)
- Harder to query sagas ("What happened on 2024-01-15?" → must know RunId first)
- Must persist RunId mapping (additional table)

**Reason for rejection:** Loses clarity; harder to debug

### Alternative 3: Composite Key for Everything (PortfolioId + Date + Type)

**Description:** Always use `PortfolioId + Date + OperationType` for all sagas.

**Pros:**
- Consistent pattern
- Maximum uniqueness

**Cons:**
- Overkill for system-wide operations (CloseOfDay has no PortfolioId)
- Requires dummy PortfolioId for global operations
- More complex queries

**Reason for rejection:** Overcomplicates simple cases

## References

- [Rebus Saga Documentation](https://github.com/rebus-org/Rebus/wiki/Sagas)
- [Close of Day Saga](../architecture/sagas/close-of-day-saga.md)
- ADR-001: PipelineMode Strategy
- GitHub Issue: #456 (Duplicate saga instances) [example]
